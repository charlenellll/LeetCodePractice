Given a linked list, determine if it has a cycle in it.

Follow up:
Can you solve it without using extra space?

# Solutions

## Normal solution: compare different OBJECT!

	O(n) Time, O(n) space

从物理上判断两个对象是不是同一个对象，而不是值!

我一开始竟然想不出来这道题除了快慢指针的简单做法，即O(n) space的做法，因为如果链表里有很多重复值的话，不能用set确保找到环。

后来看了分析才茅塞顿开！天啊！明明是面向对象的，我为什么要用值来判断两个对象是否相等？

要从物理上判断2个对象是否相等，用 == 就可以了。或者用指针，也是指向对象本身，可以通过比较指针知道它们是不是物理上的同一个对象。

因此只要用一个装着ListNode\*的set就OK！

## Follow up solution: no extra space: use fast and slow pointers

	O(n) Time, no extra space

为什么用快慢指针找链表的环，快指针和慢指针一定会相遇？

可以用数学归纳法来思考。首先，由于链表是个环，所以相遇的过程可以看作是快指针从后边追赶慢指针的过程。那么做如下思考：  
1：快指针与慢指针之间差一步。此时继续往后走，慢指针前进一步，快指针前进两步，两者相遇。
2：快指针与慢指针之间差两步。此时唏嘘往后走，慢指针前进一步，快指针前进两步，两者之间相差一步，转化为第一种情况。
3：快指针与慢指针之间差N步。此时继续往后走，慢指针前进一步，快指针前进两步，两者之间相差(N+1-2)-> N-1步。

因此，此题得证。所以==快指针必然与慢指针相遇。又因为快指针速度是慢指针的两倍，所以相遇时必然只绕了一圈(当快指针速度是慢指针的两倍时)==。如果速度比不同，最终都会相遇，只是圈数不同。

或者更直观的理解：当快指针的速度是慢指针的两倍时，相对于慢指针每次前进一格，如果有环，必定能一格一格靠近慢指针直到追击成功。